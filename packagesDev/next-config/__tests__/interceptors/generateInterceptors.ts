import { generateInterceptors } from '../../src/interceptors/generateInterceptors'
import { resolveDependency } from '../../src/utils/resolveDependency'

const projectRoot = `${process.cwd()}/examples/magento-graphcms`

it('it replaces paths and creates a relative path', () => {
  const resolver = resolveDependency(projectRoot)
  const resolved = resolver('@graphcommerce/magento-cart-payment-method')
  expect(resolved.fromRoot).toMatchInlineSnapshot(`"packages/magento-cart-payment-method/index"`)
  expect(resolved.fromModule).toBe('.')
  expect(resolved.root).toBe('packages/magento-cart-payment-method')

  const resolved2 = resolver(
    '@graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext',
  )
  expect(resolved2.fromRoot).toMatchInlineSnapshot(
    `"packages/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext"`,
  )
  expect(resolved2.fromModule).toBe('./PaymentMethodContext')
  expect(resolved2.root).toBe('packages/magento-cart-payment-method')
})

it('it generates an interceptor', () => {
  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(
    [
      {
        component: 'PaymentMethodContextProvider',
        enabled: true,
        exported: '@graphcommerce/magento-cart-payment-method/index',
        plugin: '@graphcommerce/mollie-magento-payment/plugins/AddMollieMethods',
      },
      {
        component: 'PaymentMethodContextProvider',
        enabled: true,
        exported: '@graphcommerce/magento-cart-payment-method/index',
        plugin: '@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods',
      },
    ],
    resolve,
  )

  expect(Object.keys(interceptors)[0]).toBe(
    'packages/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext',
  )

  expect(
    interceptors['packages/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext']
      ?.template,
  ).toMatchInlineSnapshot(`
    "/* This file is automatically generated for @graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext */

    import type { InterceptorProps } from '@graphcommerce/next-config'
    import { Plugin as AddBraintreeMethods } from '@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods'
    import { Plugin as AddMollieMethods } from '@graphcommerce/mollie-magento-payment/plugins/AddMollieMethods'

    /** ❗️ Original (modified) source starts here: */
    import { useApolloClient } from "@graphcommerce/graphql";
    import { useCartQuery, useClearCurrentCartId } from "@graphcommerce/magento-cart";
    import { useEventCallback } from "@mui/material";
    import { useRouter } from "next/router";
    import React, { useContext, useEffect, useMemo, useState } from "react";
    import { ExpandPaymentMethodsContext, PaymentMethod, PaymentMethodModules, PaymentModule } from "../Api/PaymentMethod";
    import { PaymentMethodContextFragment } from "../Api/PaymentMethodContext.gql";
    import { GetPaymentMethodContextDocument } from "./GetPaymentMethodContext.gql";
    type PaymentMethodContextProps = {
        methods: PaymentMethod[];
        selectedMethod?: PaymentMethod;
        setSelectedMethod: (method: PaymentMethod | undefined) => void;
        modules: PaymentMethodModules;
        selectedModule?: PaymentModule;
        setSelectedModule: (module: PaymentModule | undefined) => void;
        onSuccess: (orderNumber: string) => Promise<void>;
    };
    const paymentMethodContext = React.createContext<PaymentMethodContextProps | undefined>(undefined);
    paymentMethodContext.displayName = "PaymentMethodContext";
    export type PaymentMethodContextProviderProps = {
        modules?: PaymentMethodModules;
        children: React.ReactNode;
        successUrl?: string;
        onSuccess?: (orderNumber: string, cart?: PaymentMethodContextFragment | null) => Promise<void> | void;
    };
    export function PaymentMethodContextProvider_original(props: PaymentMethodContextProviderProps) {
        const { modules = {}, successUrl = "/checkout/success", onSuccess, children } = props;
        const context = useCartQuery(GetPaymentMethodContextDocument);
        const client = useApolloClient();
        const clearCurrentCartId = useClearCurrentCartId();
        const { push } = useRouter();
        const cartContext: ExpandPaymentMethodsContext = useMemo(()=>({
                ...context?.data?.cart,
                client
            }), [
            client,
            context?.data?.cart
        ]);
        const onSuccessCb: NonNullable<PaymentMethodContextProps["onSuccess"]> = useEventCallback(async (orderNumber)=>{
            await onSuccess?.(orderNumber, context.data?.cart);
            await push({
                pathname: successUrl,
                query: {
                    order_number: orderNumber,
                    cart_id: context.data?.cart?.id
                }
            });
            clearCurrentCartId();
        });
        const [methods, setMethods] = useState<PaymentMethod[]>([]);
        const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>();
        const [selectedModule, setSelectedModule] = useState<PaymentModule>();
        const availableMethods = useMemo(()=>{
            const allMethods = cartContext?.available_payment_methods ?? [];
            const free = allMethods.find((method)=>method?.code === "free");
            return free ? [
                free
            ] : allMethods;
        }, [
            cartContext?.available_payment_methods
        ]);
        useEffect(()=>{
            if (!cartContext) return;
            (async ()=>{
                const promises = availableMethods.map(async (method)=>method ? modules[method.code]?.expandMethods?.(method, cartContext) ?? [
                        {
                            ...method,
                            child: ""
                        }
                    ] : Promise.resolve([]));
                const loaded = (await Promise.all(promises)).flat(1).sort((a)=>(a.preferred ? 1 : 0));
                setMethods(loaded);
            })();
        }, [
            availableMethods,
            cartContext,
            modules
        ]);
        const value = useMemo(()=>({
                methods,
                selectedMethod,
                setSelectedMethod,
                modules,
                selectedModule,
                setSelectedModule,
                onSuccess: onSuccessCb
            }), [
            methods,
            modules,
            onSuccessCb,
            selectedMethod,
            selectedModule
        ]);
        return (<paymentMethodContext.Provider value={value}>

          {Object.entries(modules).map(([code, module])=>module.PaymentHandler ? <module.PaymentHandler key={code} code={code}/> : null)}

          {children}

        </paymentMethodContext.Provider>);
    }
    export function usePaymentMethodContext(optional: true): PaymentMethodContextProps | undefined;
    export function usePaymentMethodContext(optional?: false): PaymentMethodContextProps;
    export function usePaymentMethodContext(optional = false) {
        const context = useContext(paymentMethodContext);
        if (!optional && typeof context === "undefined") {
            throw Error("usePaymentMethodContext must be used within a PaymentMethodContextProvider or provide the optional=true argument");
        }
        return useContext(paymentMethodContext);
    }

    /** ❗️ Original (modified) source ends here **/

    /**
     * Interceptor for \`<PaymentMethodContextProvider/>\` with these plugins:
     * 
     * - \`@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods\`
     * - \`@graphcommerce/mollie-magento-payment/plugins/AddMollieMethods\`
     */
    const AddBraintreeMethodsPrev = (props: InterceptorProps<typeof AddBraintreeMethods>) => (
      <AddBraintreeMethods {...props} Prev={PaymentMethodContextProvider_original} />
    )
    export const PaymentMethodContextProvider = (props: InterceptorProps<typeof AddMollieMethods>) => (
      <AddMollieMethods {...props} Prev={AddBraintreeMethodsPrev} />
    )
    "
  `)
})

it('resolves a root plugin to be relative to the interceptor', () => {
  const interceptors = generateInterceptors(
    [
      {
        component: 'PaymentMethodContextProvider',
        enabled: true,
        exported: '@graphcommerce/magento-cart-payment-method',
        plugin: '@graphcommerce/magento-graphcms/plugins/AddPaymentMethodEnhancer',
      },
    ],
    resolveDependency(projectRoot),
  )
  expect(
    interceptors['packages/magento-cart-payment-method/index']?.template,
  ).toMatchInlineSnapshot(`undefined`)
})

it('it can apply multiple plugins to a single export', () => {
  const plugins = [
    {
      component: 'PaymentMethodContextProvider',
      enabled: true,
      exported:
        '@graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext',
      plugin: '@graphcommerce/mollie-magento-payment/plugins/AddMollieMethods',
    },
    // {
    //   component: 'OneMoreComponent',
    //   enabled: true,
    //   exported:
    //     '@graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext',
    //   plugin: '@graphcommerce/magento-payment-braintree/plugins/AddOneMore',
    // },
  ]

  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(plugins, resolve)
  expect(
    interceptors['packages/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext']
      ?.template,
  ).toMatchInlineSnapshot(`
    "/* This file is automatically generated for @graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext */

    import type { InterceptorProps } from '@graphcommerce/next-config'
    import { Plugin as AddMollieMethods } from '@graphcommerce/mollie-magento-payment/plugins/AddMollieMethods'

    /** ❗️ Original (modified) source starts here: */
    import { useApolloClient } from "@graphcommerce/graphql";
    import { useCartQuery, useClearCurrentCartId } from "@graphcommerce/magento-cart";
    import { useEventCallback } from "@mui/material";
    import { useRouter } from "next/router";
    import React, { useContext, useEffect, useMemo, useState } from "react";
    import { ExpandPaymentMethodsContext, PaymentMethod, PaymentMethodModules, PaymentModule } from "../Api/PaymentMethod";
    import { PaymentMethodContextFragment } from "../Api/PaymentMethodContext.gql";
    import { GetPaymentMethodContextDocument } from "./GetPaymentMethodContext.gql";
    type PaymentMethodContextProps = {
        methods: PaymentMethod[];
        selectedMethod?: PaymentMethod;
        setSelectedMethod: (method: PaymentMethod | undefined) => void;
        modules: PaymentMethodModules;
        selectedModule?: PaymentModule;
        setSelectedModule: (module: PaymentModule | undefined) => void;
        onSuccess: (orderNumber: string) => Promise<void>;
    };
    const paymentMethodContext = React.createContext<PaymentMethodContextProps | undefined>(undefined);
    paymentMethodContext.displayName = "PaymentMethodContext";
    export type PaymentMethodContextProviderProps = {
        modules?: PaymentMethodModules;
        children: React.ReactNode;
        successUrl?: string;
        onSuccess?: (orderNumber: string, cart?: PaymentMethodContextFragment | null) => Promise<void> | void;
    };
    export function PaymentMethodContextProvider_original(props: PaymentMethodContextProviderProps) {
        const { modules = {}, successUrl = "/checkout/success", onSuccess, children } = props;
        const context = useCartQuery(GetPaymentMethodContextDocument);
        const client = useApolloClient();
        const clearCurrentCartId = useClearCurrentCartId();
        const { push } = useRouter();
        const cartContext: ExpandPaymentMethodsContext = useMemo(()=>({
                ...context?.data?.cart,
                client
            }), [
            client,
            context?.data?.cart
        ]);
        const onSuccessCb: NonNullable<PaymentMethodContextProps["onSuccess"]> = useEventCallback(async (orderNumber)=>{
            await onSuccess?.(orderNumber, context.data?.cart);
            await push({
                pathname: successUrl,
                query: {
                    order_number: orderNumber,
                    cart_id: context.data?.cart?.id
                }
            });
            clearCurrentCartId();
        });
        const [methods, setMethods] = useState<PaymentMethod[]>([]);
        const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>();
        const [selectedModule, setSelectedModule] = useState<PaymentModule>();
        const availableMethods = useMemo(()=>{
            const allMethods = cartContext?.available_payment_methods ?? [];
            const free = allMethods.find((method)=>method?.code === "free");
            return free ? [
                free
            ] : allMethods;
        }, [
            cartContext?.available_payment_methods
        ]);
        useEffect(()=>{
            if (!cartContext) return;
            (async ()=>{
                const promises = availableMethods.map(async (method)=>method ? modules[method.code]?.expandMethods?.(method, cartContext) ?? [
                        {
                            ...method,
                            child: ""
                        }
                    ] : Promise.resolve([]));
                const loaded = (await Promise.all(promises)).flat(1).sort((a)=>(a.preferred ? 1 : 0));
                setMethods(loaded);
            })();
        }, [
            availableMethods,
            cartContext,
            modules
        ]);
        const value = useMemo(()=>({
                methods,
                selectedMethod,
                setSelectedMethod,
                modules,
                selectedModule,
                setSelectedModule,
                onSuccess: onSuccessCb
            }), [
            methods,
            modules,
            onSuccessCb,
            selectedMethod,
            selectedModule
        ]);
        return (<paymentMethodContext.Provider value={value}>

          {Object.entries(modules).map(([code, module])=>module.PaymentHandler ? <module.PaymentHandler key={code} code={code}/> : null)}

          {children}

        </paymentMethodContext.Provider>);
    }
    export function usePaymentMethodContext(optional: true): PaymentMethodContextProps | undefined;
    export function usePaymentMethodContext(optional?: false): PaymentMethodContextProps;
    export function usePaymentMethodContext(optional = false) {
        const context = useContext(paymentMethodContext);
        if (!optional && typeof context === "undefined") {
            throw Error("usePaymentMethodContext must be used within a PaymentMethodContextProvider or provide the optional=true argument");
        }
        return useContext(paymentMethodContext);
    }

    /** ❗️ Original (modified) source ends here **/

    /**
     * Interceptor for \`<PaymentMethodContextProvider/>\` with these plugins:
     * 
     * - \`@graphcommerce/mollie-magento-payment/plugins/AddMollieMethods\`
     */
    export const PaymentMethodContextProvider = (props: InterceptorProps<typeof AddMollieMethods>) => (
      <AddMollieMethods {...props} Prev={PaymentMethodContextProvider_original} />
    )
    "
  `)
})

it('it handles on duplicates gracefully', () => {
  const plugins = [
    {
      component: 'PaymentMethodContextProvider',
      enabled: true,
      exported:
        '@graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext',
      plugin: '@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods',
    },
    {
      component: 'PaymentMethodContextProvider',
      enabled: true,
      exported:
        '@graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext',
      plugin: '@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods',
    },
  ]

  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(plugins, resolve)
  expect(
    interceptors['packages/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext']
      ?.template,
  ).toMatchInlineSnapshot(`
    "/* This file is automatically generated for @graphcommerce/magento-cart-payment-method/PaymentMethodContext/PaymentMethodContext */

    import type { InterceptorProps } from '@graphcommerce/next-config'
    import { Plugin as AddBraintreeMethods } from '@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods'

    /** ❗️ Original (modified) source starts here: */
    import { useApolloClient } from "@graphcommerce/graphql";
    import { useCartQuery, useClearCurrentCartId } from "@graphcommerce/magento-cart";
    import { useEventCallback } from "@mui/material";
    import { useRouter } from "next/router";
    import React, { useContext, useEffect, useMemo, useState } from "react";
    import { ExpandPaymentMethodsContext, PaymentMethod, PaymentMethodModules, PaymentModule } from "../Api/PaymentMethod";
    import { PaymentMethodContextFragment } from "../Api/PaymentMethodContext.gql";
    import { GetPaymentMethodContextDocument } from "./GetPaymentMethodContext.gql";
    type PaymentMethodContextProps = {
        methods: PaymentMethod[];
        selectedMethod?: PaymentMethod;
        setSelectedMethod: (method: PaymentMethod | undefined) => void;
        modules: PaymentMethodModules;
        selectedModule?: PaymentModule;
        setSelectedModule: (module: PaymentModule | undefined) => void;
        onSuccess: (orderNumber: string) => Promise<void>;
    };
    const paymentMethodContext = React.createContext<PaymentMethodContextProps | undefined>(undefined);
    paymentMethodContext.displayName = "PaymentMethodContext";
    export type PaymentMethodContextProviderProps = {
        modules?: PaymentMethodModules;
        children: React.ReactNode;
        successUrl?: string;
        onSuccess?: (orderNumber: string, cart?: PaymentMethodContextFragment | null) => Promise<void> | void;
    };
    export function PaymentMethodContextProvider_original(props: PaymentMethodContextProviderProps) {
        const { modules = {}, successUrl = "/checkout/success", onSuccess, children } = props;
        const context = useCartQuery(GetPaymentMethodContextDocument);
        const client = useApolloClient();
        const clearCurrentCartId = useClearCurrentCartId();
        const { push } = useRouter();
        const cartContext: ExpandPaymentMethodsContext = useMemo(()=>({
                ...context?.data?.cart,
                client
            }), [
            client,
            context?.data?.cart
        ]);
        const onSuccessCb: NonNullable<PaymentMethodContextProps["onSuccess"]> = useEventCallback(async (orderNumber)=>{
            await onSuccess?.(orderNumber, context.data?.cart);
            await push({
                pathname: successUrl,
                query: {
                    order_number: orderNumber,
                    cart_id: context.data?.cart?.id
                }
            });
            clearCurrentCartId();
        });
        const [methods, setMethods] = useState<PaymentMethod[]>([]);
        const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>();
        const [selectedModule, setSelectedModule] = useState<PaymentModule>();
        const availableMethods = useMemo(()=>{
            const allMethods = cartContext?.available_payment_methods ?? [];
            const free = allMethods.find((method)=>method?.code === "free");
            return free ? [
                free
            ] : allMethods;
        }, [
            cartContext?.available_payment_methods
        ]);
        useEffect(()=>{
            if (!cartContext) return;
            (async ()=>{
                const promises = availableMethods.map(async (method)=>method ? modules[method.code]?.expandMethods?.(method, cartContext) ?? [
                        {
                            ...method,
                            child: ""
                        }
                    ] : Promise.resolve([]));
                const loaded = (await Promise.all(promises)).flat(1).sort((a)=>(a.preferred ? 1 : 0));
                setMethods(loaded);
            })();
        }, [
            availableMethods,
            cartContext,
            modules
        ]);
        const value = useMemo(()=>({
                methods,
                selectedMethod,
                setSelectedMethod,
                modules,
                selectedModule,
                setSelectedModule,
                onSuccess: onSuccessCb
            }), [
            methods,
            modules,
            onSuccessCb,
            selectedMethod,
            selectedModule
        ]);
        return (<paymentMethodContext.Provider value={value}>

          {Object.entries(modules).map(([code, module])=>module.PaymentHandler ? <module.PaymentHandler key={code} code={code}/> : null)}

          {children}

        </paymentMethodContext.Provider>);
    }
    export function usePaymentMethodContext(optional: true): PaymentMethodContextProps | undefined;
    export function usePaymentMethodContext(optional?: false): PaymentMethodContextProps;
    export function usePaymentMethodContext(optional = false) {
        const context = useContext(paymentMethodContext);
        if (!optional && typeof context === "undefined") {
            throw Error("usePaymentMethodContext must be used within a PaymentMethodContextProvider or provide the optional=true argument");
        }
        return useContext(paymentMethodContext);
    }

    /** ❗️ Original (modified) source ends here **/

    /**
     * Interceptor for \`<PaymentMethodContextProvider/>\` with these plugins:
     * 
     * - \`@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods\`
     * - \`@graphcommerce/magento-payment-braintree/plugins/AddBraintreeMethods\`
     */
    const AddBraintreeMethodsPrev = (props: InterceptorProps<typeof AddBraintreeMethods>) => (
      <AddBraintreeMethods {...props} Prev={PaymentMethodContextProvider_original} />
    )
    "
  `)
})

it('correctly renames all variable usages', () => {
  const plugins = [
    {
      enabled: true,
      exported: '@graphcommerce/magento-product',
      component: 'ProductListItem',
      plugin: '@graphcommerce/magento-compare/plugins/CompareAbleProductListItem',
    },
  ]

  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(plugins, resolve)

  expect(Object.keys(interceptors)[0]).toMatchInlineSnapshot(
    `"packages/magento-product/components/ProductListItem/ProductListItem"`,
  )

  const template =
    interceptors['packages/magento-product/components/ProductListItem/ProductListItem']?.template
  expect(template).not.toContain('ProductListItem.selectors')
  expect(template).toContain('ProductListItem_original.selectors')
})

it('it handles root plugins', () => {
  const plugins = [
    {
      component: 'AddProductsToCartForm',
      enabled: true,
      exported: '@graphcommerce/magento-product',
      plugin: './plugins/EnableCrosssellsPlugin',
    },
  ]
  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(plugins, resolve)

  expect(interceptors['packages/magento-product/index']?.template).toMatchInlineSnapshot(
    `undefined`,
  )
})

it('it handles root plugins deeper nested', () => {
  const plugins = [
    {
      component: 'OverlaySsr',
      enabled: true,
      exported: '@graphcommerce/next-ui/Overlay/components/OverlaySsr',
      plugin: './plugins/EnableCrosssellsPlugin',
    },
  ]
  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(plugins, resolve)

  expect(
    interceptors['packages/next-ui/Overlay/components/OverlaySsr'].components.OverlaySsr[0].plugin,
  ).toMatchInlineSnapshot(`"../../../../examples/magento-graphcms/plugins/EnableCrosssellsPlugin"`)
})

it('generates method interceptors alognside component interceptors', () => {
  const plugins = [
    {
      enabled: true,
      exported: '@graphcommerce/graphql',
      component: 'GraphQLProvider',
      plugin: '@graphcommerce/magento-graphql/plugins/MagentoGraphqlGraphqlProvider',
    },
    {
      enabled: true,
      exported: '@graphcommerce/graphql',
      func: 'graphqlConfig',
      plugin: '@graphcommerce/magento-graphql/plugins/magentoInitMemoryCache',
    },
    {
      enabled: true,
      exported: '@graphcommerce/graphql',
      func: 'graphqlConfig',
      plugin: '@graphcommerce/magento-hygraph/plugins/hygraphInitMemoryCache',
    },
  ]

  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(plugins, resolve)

  expect(interceptors['packages/graphql/index']?.template).toMatchInlineSnapshot(`undefined`)
})

it('adds debug logging to interceptors for components', () => {
  const plugins = [
    {
      enabled: true,
      exported: '@graphcommerce/graphql',
      component: 'GraphQLProvider',
      plugin: '@graphcommerce/magento-graphql/plugins/MagentoGraphqlGraphqlProvider',
    },
    {
      enabled: true,
      exported: '@graphcommerce/graphql',
      func: 'graphqlConfig',
      plugin: '@graphcommerce/magento-graphql/plugins/magentoInitMemoryCache',
    },
    {
      enabled: true,
      exported: '@graphcommerce/graphql',
      func: 'graphqlConfig',
      plugin: '@graphcommerce/magento-hygraph/plugins/hygraphInitMemoryCache',
    },
  ]

  const resolve = resolveDependency(projectRoot)
  const interceptors = generateInterceptors(plugins, resolve, { pluginStatus: true })

  expect(interceptors['packages/graphql/index']?.template).toMatchInlineSnapshot(`undefined`)
})
